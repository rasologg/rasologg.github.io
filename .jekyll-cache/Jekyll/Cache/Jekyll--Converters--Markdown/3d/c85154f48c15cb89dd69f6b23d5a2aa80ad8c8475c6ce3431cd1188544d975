I".‘<h1 id="quest-ce-quune-image-">Quâ€™est ce quâ€™une image ?</h1>

<p>Dans le monde de Kubernetes, une image est une encapsulation dâ€™une application (par exemple un microservice) sous une forme portable, facile Ã  dÃ©ployer. Lâ€™image contient tous les fichiers que lâ€™application a besoin pour fonctionner correctement, et elle est construite Ã  partir dâ€™un mini-noyaux Linux.</p>

<p>Une fois lancÃ©e, une image devient un conteneur, donc un conteneur est une instance dâ€™une image.</p>

<p>Il y a plusieurs faÃ§ons de crÃ©er une image :</p>
<ul>
  <li>via un fichier Dockerfile</li>
  <li>via dâ€™autres outils comme <a href="https://github.com/GoogleContainerTools/jib">Jib</a> pour les developpeurs Java.</li>
</ul>

<p>Voici un exemple dâ€™un Dockerfile :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM nginx:alpine
MAINTAINER GÃ©gÃ© Rasolo
COPY index.html /usr/share/nginx/html/index.html
</code></pre></div></div>

<p>Une image un ensemble des couches et toujours construite Ã  partir dâ€™une autre image. Dans lâ€™exemple ci-dessus, on part de lâ€™image â€œnginx:alpineâ€, qui elle est basÃ©e sur une autre image â€œalpineâ€ et ainsi de suite.</p>

<p>Si on souhaite construire une image Ã  partir de zero, on utilise lâ€™instruction â€œFROM scratchâ€,  https://hub.docker.com/_/scratch une image vide qui permet de crÃ©er â€œfrom scratchâ€.</p>

<p>Par exemple, lâ€™image <a href="https://github.com/docker-library/busybox/blob/master/Dockerfile.template">busybox</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM scratch
ADD busybox.tar.xz /
CMD ["sh"]
</code></pre></div></div>

<p><a href="https://github.com/GoogleContainerTools/jib">Jib</a>, est un outil open-source, 100% en Java, developpÃ© par Google, il permet de construire facilement une image sans avoir besoin dâ€™un daemon comme Docker.</p>

<h1 id="quest-ce-quun-conteneur-">Quâ€™est ce quâ€™un conteneur ?</h1>

<p>Un conteneur est une instance dâ€™une image. Si on compate Ã  la programmation orientÃ© objet, image est un â€œClassâ€, un conteneur est un â€œobjectâ€.</p>

<p>Le conteneur peut fonctionner sur nâ€™importe quel systÃ¨me compatible, sur nâ€™importe quel Cloud, sans aucun changement.</p>

<p>Pour demarrer un conteneur, il faut un â€œruntimeâ€, ce conteneur â€œruntimeâ€ permet Ã  lâ€™application (conteneur) de communiquer Ã  la machine hÃ´te et donc dâ€™utiliser les resources necessaires (CPU, RAM, Disque, Reseaux).</p>

<p>Conteneur runtime : docker, lxc, runc, cri-o, rkt, containerd, podman, buildah.</p>

<p><img src="/assets/images/kubernetes-developper-application-container.png" alt="Kubernetes container" /></p>

<p>Un conteneur est fortement inspirÃ© des fonctionnalitÃ©s offertes par le systeme Linux.</p>

<p>Au sein du â€œruntimeâ€, chaque conteneur est isolÃ© par le concept de â€œnamespacesâ€. Cette isolation sâ€™applique sur le reseau (network), fichier (file), utilisateurs (users), processus (processes), et les communications inter-processus (IPCs).</p>

<p>Lâ€™utilisation dâ€™un conteneur est standardisÃ© et suit la specification dâ€™OCI (Open Containers Initiative) https://opencontainers.org. Ce qui permet de deployer et executer nâ€™importe quel conteneur sur nâ€™impore quel â€œruntimeâ€.</p>

<p>On peut tÃ©lÃ©charger une image depuis des plateformes comme https://hub.docker.com/, https://quay.io/, et bien dâ€™autres.</p>

<p>Lâ€™exemple suivant nous montre comment on lance un conteneur Ã  partir de lâ€™image â€œnginx:1.19â€. Sachant que jâ€™utilise le â€œruntimeâ€ docker sur mon ordinateur, le â€œruntimeâ€ tÃ©lÃ©charge automatiquement lâ€™image depuis la plateforme docker.io si lâ€™image nâ€™est pas disponible en local. Câ€™est comme si on Ã©crit (docker.io/nginx:1.19 Ã  la place de nginx:1.19 seulement)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --name mon-serveur-web -d nginx:1.19
Unable to find image 'nginx:1.19' locally
1.19: Pulling from library/nginx
75646c2fb410: Pull complete
6128033c842f: Pull complete
71a81b5270eb: Pull complete
b5fc821c48a1: Pull complete
da3f514a6428: Pull complete
3be359fed358: Pull complete
Digest: sha256:bae781e7f518e0fb02245140c97e6ddc9f5fcf6aecc043dd9d17e33aec81c832
Status: Downloaded newer image for nginx:1.19
99d68c4d2eb755d3c094084d46006c26bf6f32ebf133fe436b9fadc6739b7163
</code></pre></div></div>

<p>Et pour vÃ©rifier que notre serveur web Nginx est maintenant lancÃ© :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker ps
99d68c4d2eb7   nginx:1.19                       "/docker-entrypoint.â€¦"   30 seconds ago   Up 29 seconds   80/tcp    mon-serveur-web
</code></pre></div></div>

<h1 id="kubernetes">Kubernetes</h1>

<p>Un systeme dâ€™information contient majoritairement beaucoup dâ€™applications, et donc beaucoup de conteneurs Ã  deployer, Ã§a peut Ãªtre deployÃ©e sur une seule grosse machine (pas vraiment une bonne idÃ©e), Ã§a peut Ãªtre sur plusieures machines en mode cluster ou sur le cloud.</p>

<p>Plusieurs solutions sont possible mais nous nous interessons sur Kubernetes qui est devenu, de facto, le systeme dâ€™orchestration des conteneurs.</p>

<p>Mais Ã  titre dâ€™information, on peut utiliser :</p>
<ul>
  <li><a href="https://docs.docker.com/compose/">Docker compose</a> permet de dÃ©ployer plusieurs conteneurs sur une seule machine en une seule commande, encore fois, nâ€™est une bonne idÃ©e pour la production.</li>
  <li><a href="https://docs.docker.com/engine/swarm/">Docker swarm</a> on peut dire que câ€™est le concurrent de Kubernetes, simple Ã  mettre en place.</li>
</ul>

<p>DeveloppÃ©e par Google, rendu public en 2014 et premier release en 2015 et maintenant appartient Ã  la fondation Linux. Kubernetes est developpÃ© en <a href="https://golang.org/">GoLang</a>.</p>

<p>https://research.google/pubs/pub43438/</p>

<p>Comme les projets Linux, il y a beaucoup de distribution de Kubernetes, on peut utiliser la distribution originale â€œKubernetes Vanillaâ€, gÃ©rÃ©e par la communautÃ©,  mais on peut aussi choisir dâ€™autres distributions comme OpenShift de chez RedHat etcâ€¦ https://kubernetes.io/fr/docs/setup/pick-right-solution/</p>

<p>Si on simplifie, Kubernetes est un RESTful API qui expose toutes les operations possibles Ã  faire sur sa base de donnÃ©es, qui est une base de donnÃ©es NoSQL ETCD.</p>

<p><img src="/assets/images/kubernetes-developper-application-api-server.png" alt="Screenshot" /></p>

<h2 id="dashbord">dashbord</h2>

<p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">Kubernest dashboard</a></p>

<p>Kubernetes IDE comme <a href="https://k8slens.dev/">Lens</a></p>

<h2 id="kubectl">kubectl</h2>
<p>Lâ€™outil pour administrer Kubernetes, kubectl est basÃ© sur curl.</p>

<p>https://kubernetes.io/docs/reference/kubectl/cheatsheet/
https://kubectl.docs.kubernetes.io/</p>

<h2 id="curl">curl</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl proxy --port=8001 &amp;
curl http://localhost:8001
curl http://localhost:8001/api/v1/namespaces/default/pods
</code></pre></div></div>

<h1 id="architecture-de-kubernetes">Architecture de Kubernetes</h1>

<p><img src="/assets/images/kubernetes-developper-application-architecture.png" alt="Architecture de Kubernetes" /></p>

<h2 id="lapi-kube-apiserver">Lâ€™API (kube-apiserver)</h2>

<p>Toutes les fonctionnalitÃ©s de Kubernetes sont accessible via API RESTful.</p>

<p>Plusieurs API-Resources : apps, networking, storage, â€¦</p>

<p>Tous les 3 mois il y a un update dâ€™API, il faut bien identifier la version Ã  utiliser.</p>

<p>Pour savoir la version de lâ€™API utilisÃ©e par le cluster, il suffit de lancer la commande suivante :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl api-versions
</code></pre></div></div>

<h2 id="lorchestrateur-kube-scheduler">Lâ€™orchestrateur (kube-scheduler)</h2>

<p>//TODO</p>

<h2 id="le-controlleur-kube-controller-manager">Le Controlleur (kube-controller-manager)</h2>

<p>On peut resumer son rÃ´le avec le bout de code ci-dessous :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
    desired := getDesiredState()
    current := getCurrentState()
    makeChanges(desired, current)
}
</code></pre></div></div>

<h2 id="lagent-kubelet">Lâ€™agent (kubelet)</h2>

<p>Lâ€™agent de Kubernetes qui se trouvent sur chaque noeuds du clusteur. Cet agent qui recoit et execute les ordres venant de lâ€™orchestrateur. Il remonte aussi toutes les informations au master via lâ€™API et ces informations sont stockÃ©es dans la base de donnÃ©es ETCD.</p>

<h2 id="kubeproxy">kubeproxy</h2>

<p>//TODO</p>

<h2 id="etcd">ETCD</h2>

<p>//TODO</p>

<h1 id="deployer-un-mini-cluster-kubernetes-pour-le-developpement">Deployer un mini-cluster Kubernetes pour le developpement</h1>

<p>Plusieurs solutions sont disponibles :</p>

<ul>
  <li><a href="https://www.docker.com/products/docker-desktop">DockerDesktop</a> : simple et facile Ã  mettre en place pour Windows et MacOS.</li>
  <li><a href="https://minikube.sigs.k8s.io/docs/start/">Minikube</a> pour Linux, macOS et windows.</li>
</ul>

<p>Personnellement, je travaille sur DockerDesktop pour macOS</p>

<h2 id="quelques-commandes-pour-tester-notre-cluster">Quelques commandes pour tester notre cluster</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl version
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Client Version: version.Info{Major:"1", Minor:"19", GitVersion:"v1.19.7", GitCommit:"1dd5338295409edcfff11505e7bb246f0d325d15", GitTreeState:"clean", BuildDate:"2021-01-13T13:23:52Z", GoVersion:"go1.15.5", Compiler:"gc", Platform:"darwin/amd64"}
Server Version: version.Info{Major:"1", Minor:"19", GitVersion:"v1.19.7", GitCommit:"1dd5338295409edcfff11505e7bb246f0d325d15", GitTreeState:"clean", BuildDate:"2021-01-13T13:15:20Z", GoVersion:"go1.15.5", Compiler:"gc", Platform:"linux/amd64"}
</code></pre></div></div>

<p>Deployer et lancer rapidement un pod (methode imperative)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl run monnginx --image=nginx
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pod/monnginx created
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get all
NAME          READY   STATUS    RESTARTS   AGE
pod/monnginx   1/1     Running   0          3m26s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   37m
</code></pre></div></div>

<h1 id="les-principaux-objets-utilisÃ©s-par-kubernetes">Les principaux objets utilisÃ©s par Kubernetes</h1>

<h2 id="pods">Pods</h2>
<p>Est une abstration dâ€™un serveur.  Un pod peut contenir plusieurs conteneurs dans un seul namespace et ils sont exposÃ© via une seule adresse IP.</p>

<p>En production, un pod ne doit pas Ãªtre demarrÃ© tout seul, il ne sera pas redeployer quand le noeud sâ€™arrete. Un pod peut Ãªtre crÃ©Ã© Ã  partir dâ€™un deploiment, job ou cronjob.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">monnginx</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">monnginx</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl explain pods
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl explain pods.spec
</code></pre></div></div>

<p>Generalement, un pod contient un seul conteneur mais, dans certains cas on a besoin de lancer multiples conteneurs dans un pod:</p>

<ul>
  <li>init container : pour initialiser une configuration par exemple</li>
  <li>sidecar container : produire des fonctionnalitÃ©s supplementaires au conteneur principal, par exemple gestion des logs, synchronisation, metriques, tracing</li>
  <li>ambassador container</li>
  <li>adapter container</li>
</ul>

<h3 id="initcontainers">InitContainers</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">initcontainer-example</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">initContainers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">sleepy</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">alpine</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sleep'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">20'</span><span class="pi">]</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
</code></pre></div></div>

<h3 id="comment-investiguer-un-probleme-dans-un-pod-">Comment investiguer un probleme dans un pod ?</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl describe pod podname 
</code></pre></div></div>
<p>Lit le status courant du pod dans la base de donnÃ©es etcd.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl logs podname
</code></pre></div></div>

<p>Lit le contenu stdout du pod, sâ€™il y a plusieurs conteneurs il faut ajouter lâ€™option -c avec le nom du conteneur</p>

<p>kubectl exec (executer une commande dans un conteneur, sâ€™il y a plusieurs conteneurs il faut ajouter lâ€™option -c)</p>

<p>kubectl get pods â€“all-namespaces -o wide</p>

<h3 id="securitycontext-dun-pod">securityContext dâ€™un pod</h3>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span> 
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginxsecure</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">securityContext</span><span class="pi">:</span>
    <span class="na">runAsNonRoot</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span></code></pre></figure>

<h3 id="tester-laccessibilitÃ©-dun-pod">Tester lâ€™accessibilitÃ© dâ€™un pod</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward pod/podname port_externe:port_interne
</code></pre></div></div>

<h3 id="limitation-des-resources-utilisÃ©-par-un-pod">Limitation des resources utilisÃ© par un pod</h3>

<p>Par defaut un pod utilise autant de CPU et memoire pour faire son travail.
On peut controler lâ€™utilisation des resources via pod.spec.containers.resources.</p>

<p>CPU : millicore (m), 1000m est lâ€™equivalent dâ€™un 1 CPU.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>requests:
limits:
</code></pre></div></div>

<h2 id="deployments">Deployments</h2>

<p>Une entitÃ© pour standardiser la gestion des pods. Un deployment crÃ©e un autre object â€œreplicasetâ€ automatiquement, le â€œreplicasetâ€ est fortement liÃ© Ã  un â€œdeploymentâ€ et donc inutile de le gerer separement.</p>

<p>Un deploiement permet de gerer le scalabilitÃ© de lâ€™application, la strategie de mise Ã  jour et lâ€™historique.</p>

<p>Si un pod tombe en panne, le deploiement crÃ©e automatique un autre.</p>

<p>En production, il faut toujours crÃ©er un pod Ã  partir dâ€™un objet â€œdeploymentâ€.</p>

<p>Voici la structure dâ€™un fichier YAML â€œdeploymentâ€ :</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">&lt;NomApplication&gt;</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">&lt;NomApplication&gt;</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">&lt;NomApplication&gt;</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">&lt;NomApplication&gt;</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">&lt;Image&gt;</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">limits</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s">&lt;Memory&gt;</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="s">&lt;CPU&gt;</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">&lt;Port&gt;</span></code></pre></figure>

<p>Comme tous les fichiers de Kubernetes, Ã§a commence toujours par la version de lâ€™API (apiVersion). Lâ€™objet de deploiement se trouve donc dans â€œappsâ€.
â€œkindâ€ sera toujours â€œDeploymentâ€.
metadata.name : est le nom de lâ€™application Ã  deployer.
containers.image : est le chemin oÃ¹ se trouve lâ€™image, et la version.</p>

<p>Voici un exemple complet pour deployer lâ€™application Redis.</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">redis</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">redis</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">redis</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">redis:alpine</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">limits</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">128Mi"</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">500m"</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">6379</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl apply -f redis-deploy.yaml
deployment.apps/redis created
</code></pre></div></div>

<p>Verifions si lâ€™application est demarrÃ©e.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl get po -l app=redis
NAME                    READY   STATUS    RESTARTS   AGE
redis-d8c6dcd54-726rp   1/1     Running   0          24s
</code></pre></div></div>

<p>Ici, lâ€™option â€œ-lâ€ veut dire label, et donc on souhaite juste afficher les pods qui ont un label â€œappâ€ avec la valeur â€œredisâ€. Câ€™est la valeur quâ€™on a indiquÃ© dans le fichier YAML ci-dessus (spec.template.metadata.labels).</p>

<p>Et maintenant si supprime le pod :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl delete po redis-d8c6dcd54-726rp
pod "redis-d8c6dcd54-726rp" deleted
</code></pre></div></div>

<p>On constate que Kubernetes crÃ©e automatiquement une autre instance :</p>

<p>redis-d8c6dcd54-726rp                  1/1     Terminating         0          66s
redis-d8c6dcd54-xbx8j                  0/1     ContainerCreating   0          3s</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl get po -l app=redis
NAME                    READY   STATUS    RESTARTS   AGE
redis-d8c6dcd54-xbx8j   1/1     Running   0          86s
</code></pre></div></div>

<p>On a dit que lâ€™historique de deploiement est aussi gÃ©rÃ©e par lâ€™object â€œDeploymentâ€.
On peut consulter cette historique via la commande :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl rollout history deployment redis
</code></pre></div></div>
<p>Ã§a devrait afficher le resultat suivant :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deployment.apps/redis
REVISION  CHANGE-CAUSE
1         &lt;none&gt;
</code></pre></div></div>
<p>Ici on nâ€™a quâ€™une seule revision parce quâ€™on a rien modifiÃ© pour lâ€™instant.
Kubernetes suit une strategie quand une modification est faite sur le deploiment :</p>
<ul>
  <li>la stratÃ©gie â€œRecreateâ€ : Ã§a supprime lâ€™ancien pod et crÃ©e une nouvelle, Ã§a implique une petite indisponibilitÃ© du service.</li>
  <li>la stratÃ©gie â€œRollingUpdateâ€ : cette stretÃ©gie garantit la disponibilitÃ© de lâ€™application, et donc Kubernetes remplace un pod Ã  la fois.</li>
</ul>

<p>On va apporter quelques modifications Ã  notre fichier redis-deploy.yaml pour gÃ©rer la stratÃ©gie de mise Ã  jour et commenÃ§ons par une ancienne version de Redis â€œ5.0.12-alpineâ€ :</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">redis</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">4</span>
  <span class="na">strategy</span><span class="pi">:</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">RollingUpdate</span>
    <span class="na">rollingUpdate</span><span class="pi">:</span>
      <span class="na">maxSurge</span><span class="pi">:</span> <span class="m">2</span>
      <span class="na">maxUnavailable</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">redis</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">redis</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">redis:5.0.12-alpine</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">limits</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">128Mi"</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">500m"</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">6379</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl apply -f redis-deploy.yaml
deployment.apps/redis configured
</code></pre></div></div>
<p>Verifions :</p>

<pre><code class="language-`">â¯ kubectl get po -l app=redis
NAME                    READY   STATUS    RESTARTS   AGE
redis-d8c6dcd54-9bqfl   1/1     Running   0          12s
redis-d8c6dcd54-bjxjf   1/1     Running   0          12s
redis-d8c6dcd54-nnrqs   1/1     Running   0          12s
redis-d8c6dcd54-t8t26   1/1     Running   0          12s
</code></pre>
<p>Maintenant on a bien 4 replicas, comme câ€™est demandÃ© dans le fichier YAML.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl rollout history deployment redis
deployment.apps/redis
REVISION  CHANGE-CAUSE
1         &lt;none&gt;
</code></pre></div></div>

<p>Maintenant, modifions la version de Redis :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl set image deployment.apps/redis redis=redis:6-alpine
deployment.apps/redis image updated
</code></pre></div></div>

<p>VÃ©rifions si la version a Ã©tÃ© mise Ã  jour</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl get deployment.apps/redis -o=jsonpath='{$.spec.template.spec.containers[:1].image}'
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis:6-alpine
</code></pre></div></div>

<p>Et si on reconsulte lâ€™historique, la revision devrait Ãªtre 2 :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl rollout history deployment redis
deployment.apps/redis
REVISION  CHANGE-CAUSE
1         &lt;none&gt;
2         &lt;none&gt;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl rollout history deployment redis --revision=1
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deployment.apps/redis with revision #1
Pod Template:
  Labels:	app=redis
	pod-template-hash=68d544cd59
  Containers:
   redis:
    Image:	redis:5.0.12-alpine
    Port:	6379/TCP
    Host Port:	0/TCP
    Limits:
      cpu:	500m
      memory:	128Mi
    Environment:	&lt;none&gt;
    Mounts:	&lt;none&gt;
  Volumes:	&lt;none
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl rollout history deployment redis --revision=2
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>deployment.apps/redis with revision #2
Pod Template:
  Labels:	app=redis
	pod-template-hash=5f7d7d959f
  Containers:
   redis:
    Image:	redis:6-alpine
    Port:	6379/TCP
    Host Port:	0/TCP
    Limits:
      cpu:	500m
      memory:	128Mi
    Environment:	&lt;none&gt;
    Mounts:	&lt;none&gt;
  Volumes:	&lt;none&gt;
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl get replicasets.apps -l app=redis
NAME               DESIRED   CURRENT   READY   AGE
redis-5f7d7d959f   4         4         4       11m
redis-68d544cd59   0         0         0       15m
</code></pre></div></div>

<p>Si on revient en arriere</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl rollout undo deployment redis --to-revision=1
deployment.apps/redis rolled back
</code></pre></div></div>

<h2 id="services">Services</h2>

<p>Un pod tout seul nâ€™est pas accessible depuis lâ€™exterieur en tant quâ€™application.</p>

<p>Pour debugger, on peut quand meme utiliser le â€œport forwardâ€, mais ceci nâ€™est pas lâ€™utilisation normale dâ€™une application.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward pod/mynginx 8989:80
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Forwarding from 127.0.0.1:8989 -&gt; 80
Forwarding from [::1]:8989 -&gt; 80
Handling connection for 8989
</code></pre></div></div>

<p><img src="/assets/images/kubernetes-developper-application-port-forward.png" alt="Kubernetes port forward" /></p>

<p>Pour exposer lâ€™application, il faut crÃ©er un service.</p>

<p><img src="/assets/images/kubernetes-developper-application-pod-access.png" alt="Kubernetes pod access" /></p>

<p><img src="/assets/images/kubernetes-developper-application-pod-access-2.png" alt="Kubernetes pod access" /></p>

<p>Il y a plusieurs type de service :</p>

<ul>
  <li>ClusterIP : le type par dÃ©faut, et il est accessible quâ€™Ã  lâ€™interieur du cluster.</li>
  <li>NodePort : ouvre le port de lâ€™application sur le noeud, et donc on peut y acceder directement depuis lâ€™exterieur.</li>
  <li>LoadBalancer : utilisÃ© par le fourniseur cloud public.</li>
  <li>ExternalName : une sorte de redirection de nom DNS.</li>
  <li>Service sans â€œselectorâ€ : utilisÃ© pour connecter directement Ã  une IP/port par exemple un serveur de base de donnÃ©es ou une application exterieur au cluster Kubernetes.</li>
</ul>

<p>Pour exposer un service rapidement via la ligne de commande</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl expose deployment monnginx --port=80 --type=NodePort
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>service/monnginx exposed
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get service
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NAME                  TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
kubernetes            ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP        4d1h
monnginx              NodePort    10.102.160.117   &lt;none&gt;        80:32392/TCP   58s
</code></pre></div></div>

<p>Mais crÃ©er un service via la ligne de commande nâ€™est pas vraiment la bonne pratique, il faut plutÃ´t utiliser des fichiers.
Voici un exemple de fichier YAML pour crÃ©er un service :</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mon-serveur-web</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">monnginx</span>
  <span class="na">ports</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="m">80</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">mon-serveur-web</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">NodePort</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â¯ kubectl apply -f nginx-service.yaml
service/mon-serveur-web created
</code></pre></div></div>

<h2 id="ingress">Ingress</h2>
<p>//TODO</p>

<h2 id="persistent-volumes">Persistent Volumes</h2>
<p>//TODO</p>

<h2 id="jobs">Jobs</h2>

<p>Pour executer une tache pendant un certain temps defini.</p>

<p>3 differentes type de jobs :</p>
<ul>
  <li>non-parallel jobs : completions=1 parallelism=1</li>
  <li>Parallel jobs : completions=n, parallelism=m</li>
  <li>Parallel jobs avec un queue : completions=1, parallelism=n</li>
</ul>

<h2 id="cronjobs">Cronjobs</h2>

<h2 id="namespace">Namespace</h2>
<p>Pour isoler les ressources dans le cluster. Par dÃ©faut, Kubernetes crÃ©e plusieurs namespaces : default, kube-node-lease, kube-public, kube-system.</p>

<p>Pour crÃ©er un namespace :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create ns ci-env
</code></pre></div></div>
<p>Pour lancer une requete dâ€™un namespace, on utilise lâ€™option â€œ-nâ€</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl -n namespace get pods
</code></pre></div></div>
<p>Lister tous les namespaces</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get ns
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods --all-namespaces
</code></pre></div></div>

<h1 id="autorisation-et-permission">Autorisation et permission</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl auth can-i get pods
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl auth can-i get pods --as toto@test.com
</code></pre></div></div>

<h1 id="comment-on-developpe-pour-kubernetes-">Comment on developpe pour Kubernetes ?</h1>

<p>Build lâ€™application -&gt; La conteneuriser -&gt; La deployer et executer sur K8S</p>

<h2 id="developpement-continue-avec-skaffold">developpement continue avec Skaffold</h2>
<p>https://skaffold.dev/</p>

<h1 id="operator">Operator</h1>

<p>un moyen dâ€™etendre les ressources que lâ€™API Serveur de Kubernetes peut gerer. On appelle ceci CRD (Custom Resource Definitions).</p>

:ET