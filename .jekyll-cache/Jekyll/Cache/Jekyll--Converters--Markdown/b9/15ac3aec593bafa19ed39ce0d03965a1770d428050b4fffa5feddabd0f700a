I"’K<h1 id="quest-ce-quune-image-">Quâ€™est ce quâ€™une image ?</h1>

<p>Dans le monde du Kubernetes, une image est un ensemble de fichiers et repertoires construit au dessus dâ€™un mini-noyaux Linux. Câ€™est une encapsulation dâ€™une application sous une forme portable et facile Ã  dÃ©ployer. Lâ€™image contient tous les fichiers que lâ€™application a besoin pour fonctionner correctement.</p>

<p>Lors de lâ€™execution sur une machine, image devient un conteneur, un conteneur est une instance dâ€™une image.</p>

<p>Pour construire une image, il faut Ã©crire un fichier, un descripteur, communement appelÃ© Dockerfile. Dâ€™autres outils sont aussi disponible pour construire une image.</p>

<p>Voici un exemple dâ€™un Dockerfile :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM nginx:alpine
MAINTAINER GÃ©gÃ© Rasolo
COPY index.html /usr/share/nginx/html/index.html
</code></pre></div></div>

<p>Une image un ensemble des couches et construit Ã  partir dâ€™une image. Dans lâ€™exemple ci-dessus, on part de lâ€™image â€œnginx:alpineâ€ qui est disponible sur Internet, qui elle est basÃ©e sur une autre image â€œalpineâ€ et ainsi de suite.</p>

<p>Si on souhaite construire une image Ã  partir de zero, on utilise lâ€™instruction â€œFROM scratchâ€, ceci ordonne Ã  lâ€™outil (daemon Docker) de construire Ã  partir du mini-noyau linux (rootfs).</p>

<p>Par exemple, lâ€™image <a href="https://github.com/docker-library/busybox/blob/master/Dockerfile.template">busybox</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM scratch
ADD busybox.tar.xz /
CMD ["sh"]
</code></pre></div></div>

<p>Google a developpÃ© un outil open-source, 100% Java, <a href="https://github.com/GoogleContainerTools/jib">Jib</a> pour construire facilement une image sans avoir besoin dâ€™un daemon comme Docker.</p>

<h1 id="conteneur">Conteneur</h1>

<p>Un conteneur est une instance dâ€™une image. Si on compate Ã  la programmation orientÃ© objet, image est un â€œClassâ€, un conteneur est un â€œobjectâ€.</p>

<p>Le conteneur peut fonctionner sur nâ€™importe quel systÃ¨me compatible, sur nâ€™importe quel Cloud, sans aucun changement.</p>

<p>Pour demarrer un conteneur, il faut un â€œruntimeâ€, ce conteneur â€œruntimeâ€ permet Ã  lâ€™application (conteneur) de communiquer Ã  la machine hÃ´te et donc dâ€™utiliser les resources necessaires (CPU, RAM, Disque, Reseaux).</p>

<p>Conteneur runtime : docker, lxc, runc, cri-o, rkt, containerd, podman, buildah.</p>

<p><img src="/assets/images/kubernetes-developper-application-container.png" alt="Screenshot" /></p>

<p>Un conteneur est fortement inspirÃ© des fonctionnalitÃ©s offertes par le systeme Linux.</p>

<p>Au sein du â€œruntimeâ€, chaque conteneur est isolÃ© par le concept de â€œnamespacesâ€. Cette isolation sâ€™applique sur le reseau (network), fichier (file), utilisateurs (users), processus (processes), et les communications inter-processus (IPCs).</p>

<p>Lâ€™utilisation dâ€™un conteneur est standardisÃ© et suit la specification dâ€™OCI (Open Containers Initiative) https://opencontainers.org. Ce qui permet de deployer et executer nâ€™importe quel conteneur sur nâ€™impore quel â€œruntimeâ€.</p>

<p>On peut tÃ©lÃ©charger une image depuis des plateformes comme https://hub.docker.com/, https://quay.io/, et bien dâ€™autres.</p>

<p>Lâ€™exemple suivant nous montre comment on lance un conteneur Ã  partir de lâ€™image â€œnginx:1.19â€. Sachant que jâ€™utilise le â€œruntimeâ€ docker sur mon ordinateur, le â€œruntimeâ€ tÃ©lÃ©charge automatiquement lâ€™image depuis la plateforme docker.io si lâ€™image nâ€™est pas disponible en local. Câ€™est comme si on Ã©crit (docker.io/nginx:1.19 Ã  la place de nginx:1.19 seulement)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --name mon-serveur-web -d nginx:1.19
Unable to find image 'nginx:1.19' locally
1.19: Pulling from library/nginx
75646c2fb410: Pull complete
6128033c842f: Pull complete
71a81b5270eb: Pull complete
b5fc821c48a1: Pull complete
da3f514a6428: Pull complete
3be359fed358: Pull complete
Digest: sha256:bae781e7f518e0fb02245140c97e6ddc9f5fcf6aecc043dd9d17e33aec81c832
Status: Downloaded newer image for nginx:1.19
99d68c4d2eb755d3c094084d46006c26bf6f32ebf133fe436b9fadc6739b7163
</code></pre></div></div>

<p>Et pour vÃ©rifier que notre serveur web Nginx est maintenant lancÃ© :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker ps
99d68c4d2eb7   nginx:1.19                       "/docker-entrypoint.â€¦"   30 seconds ago   Up 29 seconds   80/tcp    mon-serveur-web
</code></pre></div></div>

<h1 id="kubernetes">Kubernetes</h1>

<p>Un systeme dâ€™information contient majoritairement beaucoup dâ€™applications, et donc beaucoup de conteneurs Ã  deployer, Ã§a peut Ãªtre deployÃ©e sur une seule grosse machine (pas vraiment une bonne idÃ©e), Ã§a peut Ãªtre sur plusieures machines en mode cluster ou sur le cloud.</p>

<p>Plusieurs solutions sont possible mais nous nous interessons sur Kubernetes qui est devenu, de facto, le systeme dâ€™orchestration des conteneurs.</p>

<p>Mais Ã  titre dâ€™information, on peut utiliser :</p>
<ul>
  <li><a href="https://docs.docker.com/compose/">Docker compose</a> permet de dÃ©ployer plusieurs conteneurs sur une seule machine en une seule commande, encore fois, nâ€™est une bonne idÃ©e pour la production.</li>
  <li><a href="https://docs.docker.com/engine/swarm/">Docker swarm</a> on peut dire que câ€™est le concurrent de Kubernetes, simple Ã  mettre en place.</li>
</ul>

<p>DeveloppÃ©e par Google, rendu public en 2014 et premier release en 2015 et maintenant appartient Ã  la fondation Linux. Kubernetes est developpÃ© en <a href="https://golang.org/">GoLang</a>.</p>

<p>https://research.google/pubs/pub43438/</p>

<p>Comme les projets Linux, il y a beaucoup de distribution de Kubernetes, on peut utiliser la distribution originale â€œKubernetes Vanillaâ€, gÃ©rÃ©e par la communautÃ©,  mais on peut aussi choisir dâ€™autres distributions comme OpenShift de chez RedHat etcâ€¦ https://kubernetes.io/fr/docs/setup/pick-right-solution/</p>

<p>Si on simplifie, Kubernetes est un RESTful API qui expose toutes les operations possibles Ã  faire sur sa base de donnÃ©es, qui est une base de donnÃ©es NoSQL ETCD.</p>

<p><img src="/assets/images/kubernetes-developper-application-api-server.png" alt="Screenshot" /></p>

<h2 id="dashbord">dashbord</h2>

<p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">Kubernest dashboard</a></p>

<p>Kubernetes IDE comme <a href="https://k8slens.dev/">Lens</a></p>

<h2 id="kubectl">kubectl</h2>
<p>Lâ€™outil pour administrer Kubernetes, kubectl est basÃ© sur curl.</p>

<p>https://kubernetes.io/docs/reference/kubectl/cheatsheet/
https://kubectl.docs.kubernetes.io/</p>

<h2 id="curl">curl</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl proxy --port=8001 &amp;
curl http://localhost:8001
curl http://localhost:8001/api/v1/namespaces/default/pods
</code></pre></div></div>

<h1 id="architecture-de-kubernetes">Architecture de Kubernetes</h1>

<p><img src="/assets/images/kubernetes-developper-application-architecture.png" alt="Screenshot" /></p>

<h2 id="lapi-kube-apiserver">Lâ€™API (kube-apiserver)</h2>

<p>Toutes les fonctionnalitÃ©s de Kubernetes sont accessible via API RESTful.</p>

<p>Plusieurs API-Resources : apps, networking, storage, â€¦</p>

<p>Tous les 3 mois il y a un update dâ€™API, il faut bien identifier la version Ã  utiliser.</p>

<h2 id="lorchestrateur-kube-scheduler">Lâ€™orchestrateur (kube-scheduler)</h2>

<p>//TODO</p>

<h2 id="le-controlleur-kube-controller-manager">Le Controlleur (kube-controller-manager)</h2>

<p>On peut resumer son rÃ´le avec le bout de code ci-dessous :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
    desired := getDesiredState()
    current := getCurrentState()
    makeChanges(desired, current)
}
</code></pre></div></div>

<h2 id="lagent-kubelet">Lâ€™agent (kubelet)</h2>

<p>Lâ€™agent de Kubernetes qui se trouvent sur chaque noeuds du clusteur. Cet agent qui recoit et execute les ordres venant de lâ€™orchestrateur. Il remonte aussi toutes les informations au master via lâ€™API et ces informations sont stockÃ©es dans la base de donnÃ©es ETCD.</p>

<h2 id="kubeproxy">kubeproxy</h2>

<p>//TODO</p>

<h2 id="etcd">ETCD</h2>

<p>//TODO</p>

<h1 id="deployer-un-mini-cluster-kubernetes-pour-le-developpement">Deployer un mini-cluster Kubernetes pour le developpement</h1>

<p>Plusieurs solutions sont disponibles :</p>

<ul>
  <li><a href="https://www.docker.com/products/docker-desktop">DockerDesktop</a> : simple et facile Ã  mettre en place pour Windows et MacOS.</li>
  <li><a href="https://minikube.sigs.k8s.io/docs/start/">Minikube</a> pour Linux, macOS et windows.</li>
</ul>

<p>Personnellement, je travaille sur DockerDesktop pour macOS</p>

<h2 id="quelques-commandes-pour-tester-notre-cluster">Quelques commandes pour tester notre cluster</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl version
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Client Version: version.Info{Major:"1", Minor:"19", GitVersion:"v1.19.7", GitCommit:"1dd5338295409edcfff11505e7bb246f0d325d15", GitTreeState:"clean", BuildDate:"2021-01-13T13:23:52Z", GoVersion:"go1.15.5", Compiler:"gc", Platform:"darwin/amd64"}
Server Version: version.Info{Major:"1", Minor:"19", GitVersion:"v1.19.7", GitCommit:"1dd5338295409edcfff11505e7bb246f0d325d15", GitTreeState:"clean", BuildDate:"2021-01-13T13:15:20Z", GoVersion:"go1.15.5", Compiler:"gc", Platform:"linux/amd64"}
</code></pre></div></div>

<p>Deployer et lancer rapidement un pod (methode imperative)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl run mynginx --image=nginx
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pod/mynginx created
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get all
NAME          READY   STATUS    RESTARTS   AGE
pod/mynginx   1/1     Running   0          3m26s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   37m
</code></pre></div></div>

<h1 id="les-principaux-objets-utilisÃ©s-par-kubernetes">Les principaux objets utilisÃ©s par Kubernetes</h1>

<h2 id="pods">Pods</h2>
<p>Est une abstration dâ€™un serveur.  Un pod peut contenir plusieurs conteneurs dans un seul namespace et ils sont exposÃ© via une seule adresse IP.</p>

<p>En production, un pod ne doit pas Ãªtre demarrÃ© tout seul, il ne sera pas redeployer quand le noeud sâ€™arrete. Un pod peut Ãªtre crÃ©Ã© Ã  partir dâ€™un deploiment, job ou cronjob.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mynginx</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">mynginx</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl explain pods
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl explain pods.spec
</code></pre></div></div>

<p>Generalement, un pod contient un seul conteneur mais, dans certains cas on a besoin de lancer multiples conteneurs dans un pod:</p>

<ul>
  <li>init container : pour initialiser une configuration par exemple</li>
  <li>sidecar container : produire des fonctionnalitÃ©s supplementaires au conteneur principal, par exemple gestion des logs, synchronisation, metriques, tracing</li>
  <li>ambassador container</li>
  <li>adapter container</li>
</ul>

<h3 id="initcontainers">InitContainers</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">initcontainer-example</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">initContainers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">sleepy</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">alpine</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sleep'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">20'</span><span class="pi">]</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
</code></pre></div></div>

<h3 id="comment-investiguer-un-probleme-dans-un-pod-">Comment investiguer un probleme dans un pod ?</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl describe pod podname 
</code></pre></div></div>
<p>Lit le status courant du pod dans la base de donnÃ©es etcd.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl logs podname
</code></pre></div></div>

<p>Lit le contenu stdout du pod, sâ€™il y a plusieurs conteneurs il faut ajouter lâ€™option -c avec le nom du conteneur</p>

<p>kubectl exec (executer une commande dans un conteneur, sâ€™il y a plusieurs conteneurs il faut ajouter lâ€™option -c)</p>

<p>kubectl get pods â€“all-namespaces -o wide</p>

<h3 id="securitycontext-dun-pod">securityContext dâ€™un pod</h3>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span> 
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginxsecure</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">securityContext</span><span class="pi">:</span>
    <span class="na">runAsNonRoot</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span></code></pre></figure>

<h3 id="tester-laccessibilitÃ©-dun-pod">Tester lâ€™accessibilitÃ© dâ€™un pod</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward pod/podname port_externe:port_interne
</code></pre></div></div>
<h3 id="limitation-des-resources-utilisÃ©-par-un-pod">Limitation des resources utilisÃ© par un pod</h3>

<p>Par defaut un pod utilise autant de CPU et memoire pour faire son travail.
On peut controler lâ€™utilisation des resources via pod.spec.containers.resources.</p>

<p>CPU : millicore (m), 1000m est lâ€™equivalent dâ€™un 1 CPU.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>requests:
limits:
</code></pre></div></div>

<h2 id="deployments">Deployments</h2>

<p>Une entitÃ© pour standardiser la gestion des pods. Un deployment crÃ©e un replicaset automatiquement.</p>

<p>Un deploiement permet de gerer le scalabilitÃ© de lâ€™application, la strategie de mise Ã  jour et lâ€™historique.</p>

<p>Si un pod tombe en panne, le deploiement crÃ©e automatique un autre.</p>

<h2 id="services">Services</h2>

<h2 id="ingress">Ingress</h2>

<h2 id="persistent-volumes">Persistent Volumes</h2>

<h2 id="jobs">Jobs</h2>

<p>Pour executer une tache pendant un certain temps defini.</p>

<p>3 differentes type de jobs :</p>
<ul>
  <li>non-parallel jobs : completions=1 parallelism=1</li>
  <li>Parallel jobs : completions=n, parallelism=m</li>
  <li>Parallel jobs avec un queue : completions=1, parallelism=n</li>
</ul>

<h2 id="cronjobs">Cronjobs</h2>

<h2 id="namespace">Namespace</h2>
<p>Pour isoler les ressources dans le cluster. Par dÃ©faut, Kubernetes crÃ©e plusieurs namespaces : default, kube-node-lease, kube-public, kube-system.</p>

<p>Pour crÃ©er un namespace :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create ns ci-env
</code></pre></div></div>
<p>Pour lancer une requete dâ€™un namespace, on utilise lâ€™option â€œ-nâ€</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl -n namespace get pods
</code></pre></div></div>
<p>Lister tous les namespaces</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get ns
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods --all-namespaces
</code></pre></div></div>

<h1 id="autorisation-et-permission">Autorisation et permission</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl auth can-i get pods
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl auth can-i get pods --as toto@test.com
</code></pre></div></div>

<h1 id="comment-on-developpe-pour-kubernetes-">Comment on developpe pour Kubernetes ?</h1>

<p>Build lâ€™application -&gt; La conteneuriser -&gt; La deployer et executer sur K8S</p>

<h2 id="developpement-continue-avec-skaffold">developpement continue avec Skaffold</h2>
<p>https://skaffold.dev/</p>

<h1 id="operator">Operator</h1>

<p>un moyen dâ€™etendre les ressources que lâ€™API Serveur de Kubernetes peut gerer. On appelle ceci CRD (Custom Resource Definitions).</p>

:ET