I"\K<h1 id="image">Image</h1>

<p>Un ensemble de fichiers et repertoires construit au dessus d’un mini-noyaux linux. C’est une encapsule d’une application sous une forme portable et facile à déployer. L’image contient tous les fichiers que l’application a besoin pour fonctionner correctement.</p>

<p>Lors de l’execution sur une machine, image devient un conteneur, un conteneur est une instance d’une image.</p>

<p>Pour construire une image, il faut écrire un fichier, un descripteur, communement appelé Dockerfile. D’autres outils sont aussi disponible pour construire une image.</p>

<p>Voici un exemple d’un Dockerfile :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM nginx:alpine
MAINTAINER Gégé Rasolo
COPY index.html /usr/share/nginx/html/index.html
</code></pre></div></div>

<p>Une image un ensemble des couches et construit à partir d’une image. Dans l’exemple ci-dessus, on part de l’image “nginx:alpine” qui est disponible sur Internet, qui elle est basée sur une autre image “alpine” et ainsi de suite.</p>

<p>Si on souhaite construire une image à partir de zero, on utilise l’instruction “FROM scratch”, ceci ordonne à l’outil (daemon Docker) de construire à partir du mini-noyau linux (rootfs).</p>

<p>Par exemple, l’image <a href="https://github.com/docker-library/busybox/blob/master/Dockerfile.template">busybox</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM scratch
ADD busybox.tar.xz /
CMD ["sh"]
</code></pre></div></div>

<p>Google a developpé un outil open-source, 100% Java, <a href="https://github.com/GoogleContainerTools/jib">Jib</a> pour construire facilement une image sans avoir besoin d’un daemon comme Docker.</p>

<h1 id="conteneur">Conteneur</h1>

<p>Un conteneur est une instance d’une image. Si on compate à la programmation orienté objet, image est un “Class”, un conteneur est un “object”.</p>

<p>Le conteneur peut fonctionner sur n’importe quel système compatible, sur n’importe quel Cloud, sans aucun changement.</p>

<p>Pour demarrer un conteneur, il faut un “runtime”, ce conteneur “runtime” permet à l’application (conteneur) de communiquer à la machine hôte et donc d’utiliser les resources necessaires (CPU, RAM, Disque, Reseaux).</p>

<p>Conteneur runtime : docker, lxc, runc, cri-o, rkt, containerd, podman, buildah.</p>

<p><img src="/assets/images/kubernetes-developper-application-container.png" alt="Screenshot" /></p>

<p>Un conteneur est fortement inspiré des fonctionnalités offertes par le systeme Linux.</p>

<p>Au sein du “runtime”, chaque conteneur est isolé par le concept de “namespaces”. Cette isolation s’applique sur le reseau (network), fichier (file), utilisateurs (users), processus (processes), et les communications inter-processus (IPCs).</p>

<p>L’utilisation d’un conteneur est standardisé et suit la specification d’OCI (Open Containers Initiative) https://opencontainers.org. Ce qui permet de deployer et executer n’importe quel conteneur sur n’impore quel “runtime”.</p>

<p>On peut télécharger une image depuis des plateformes comme https://hub.docker.com/, https://quay.io/, et bien d’autres.</p>

<p>L’exemple suivant nous montre comment on lance un conteneur à partir de l’image “nginx:1.19”. Sachant que j’utilise le “runtime” docker sur mon ordinateur, le “runtime” télécharge automatiquement l’image depuis la plateforme docker.io si l’image n’est pas disponible en local. C’est comme si on écrit (docker.io/nginx:1.19 à la place de nginx:1.19 seulement)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --name mon-serveur-web -d nginx:1.19
Unable to find image 'nginx:1.19' locally
1.19: Pulling from library/nginx
75646c2fb410: Pull complete
6128033c842f: Pull complete
71a81b5270eb: Pull complete
b5fc821c48a1: Pull complete
da3f514a6428: Pull complete
3be359fed358: Pull complete
Digest: sha256:bae781e7f518e0fb02245140c97e6ddc9f5fcf6aecc043dd9d17e33aec81c832
Status: Downloaded newer image for nginx:1.19
99d68c4d2eb755d3c094084d46006c26bf6f32ebf133fe436b9fadc6739b7163
</code></pre></div></div>

<p>Et pour vérifier que notre serveur web Nginx est maintenant lancé :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker ps
99d68c4d2eb7   nginx:1.19                       "/docker-entrypoint.…"   30 seconds ago   Up 29 seconds   80/tcp    mon-serveur-web
</code></pre></div></div>

<h1 id="kubernetes">Kubernetes</h1>

<p>Un systeme d’information contient majoritairement beaucoup d’applications, et donc beaucoup de conteneurs à deployer, ça peut être deployée sur une seule grosse machine (pas vraiment une bonne idée), ça peut être sur plusieures machines en mode cluster ou sur le cloud.</p>

<p>Plusieurs solutions sont possible mais nous nous interessons sur Kubernetes qui est devenu, de facto, le systeme d’orchestration des conteneurs.</p>

<p>Mais à titre d’information, on peut utiliser :</p>
<ul>
  <li><a href="https://docs.docker.com/compose/">Docker compose</a> permet de déployer plusieurs conteneurs sur une seule machine en une seule commande, encore fois, n’est une bonne idée pour la production.</li>
  <li><a href="https://docs.docker.com/engine/swarm/">Docker swarm</a> on peut dire que c’est le concurrent de Kubernetes, simple à mettre en place.</li>
</ul>

<p>Developpée par Google, rendu public en 2014 et premier release en 2015 et maintenant appartient à la fondation Linux. Kubernetes est developpé en <a href="https://golang.org/">GoLang</a>.</p>

<p>https://research.google/pubs/pub43438/</p>

<p>Comme les projets Linux, il y a beaucoup de distribution de Kubernetes, on peut utiliser la distribution originale “Kubernetes Vanilla”, gérée par la communauté,  mais on peut aussi choisir d’autres distributions comme OpenShift de chez RedHat etc… https://kubernetes.io/fr/docs/setup/pick-right-solution/</p>

<p>Si on simplifie, Kubernetes est un RESTful API qui expose toutes les operations possibles à faire sur sa base de données, qui est une base de données NoSQL ETCD.</p>

<p><img src="/assets/images/kubernetes-developper-application-api-server.png" alt="Screenshot" /></p>

<h2 id="dashbord">dashbord</h2>

<p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">Kubernest dashboard</a></p>

<p>Kubernetes IDE comme <a href="https://k8slens.dev/">Lens</a></p>

<h2 id="kubectl">kubectl</h2>
<p>L’outil pour administrer Kubernetes, kubectl est basé sur curl.</p>

<p>https://kubernetes.io/docs/reference/kubectl/cheatsheet/
https://kubectl.docs.kubernetes.io/</p>

<h2 id="curl">curl</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl proxy --port=8001 &amp;
curl http://localhost:8001
curl http://localhost:8001/api/v1/namespaces/default/pods
</code></pre></div></div>

<h1 id="architecture-de-kubernetes">Architecture de Kubernetes</h1>

<p><img src="./kubernetes-developper-application-architecture.png" alt="alt text" title="Comment fonctionne l'api de kubernetes" /></p>

<h2 id="lapi-kube-apiserver">L’API (kube-apiserver)</h2>

<p>Toutes les fonctionnalités de Kubernetes sont accessible via API RESTful.</p>

<p>Plusieurs API-Resources : apps, networking, storage, …</p>

<p>Tous les 3 mois il y a un update d’API, il faut bien identifier la version à utiliser.</p>

<h2 id="lorchestrateur-kube-scheduler">L’orchestrateur (kube-scheduler)</h2>

<p>//TODO</p>

<h2 id="le-controlleur-kube-controller-manager">Le Controlleur (kube-controller-manager)</h2>

<p>On peut resumer son rôle avec le bout de code ci-dessous :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
    desired := getDesiredState()
    current := getCurrentState()
    makeChanges(desired, current)
}
</code></pre></div></div>

<h2 id="lagent-kubelet">L’agent (kubelet)</h2>

<p>L’agent de Kubernetes qui se trouvent sur chaque noeuds du clusteur. Cet agent qui recoit et execute les ordres venant de l’orchestrateur. Il remonte aussi toutes les informations au master via l’API et ces informations sont stockées dans la base de données ETCD.</p>

<h2 id="kubeproxy">kubeproxy</h2>

<p>//TODO</p>

<h2 id="etcd">ETCD</h2>

<p>//TODO</p>

<h1 id="deployer-un-mini-cluster-kubernetes-pour-le-developpement">Deployer un mini-cluster Kubernetes pour le developpement</h1>

<p>Plusieurs solutions sont disponibles :</p>

<ul>
  <li><a href="https://www.docker.com/products/docker-desktop">DockerDesktop</a> : simple et facile à mettre en place pour Windows et MacOS.</li>
  <li><a href="https://minikube.sigs.k8s.io/docs/start/">Minikube</a> pour Linux, macOS et windows.</li>
</ul>

<p>Personnellement, je travaille sur DockerDesktop pour macOS</p>

<h2 id="quelques-commandes-pour-tester-notre-cluster">Quelques commandes pour tester notre cluster</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl version
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Client Version: version.Info{Major:"1", Minor:"19", GitVersion:"v1.19.7", GitCommit:"1dd5338295409edcfff11505e7bb246f0d325d15", GitTreeState:"clean", BuildDate:"2021-01-13T13:23:52Z", GoVersion:"go1.15.5", Compiler:"gc", Platform:"darwin/amd64"}
Server Version: version.Info{Major:"1", Minor:"19", GitVersion:"v1.19.7", GitCommit:"1dd5338295409edcfff11505e7bb246f0d325d15", GitTreeState:"clean", BuildDate:"2021-01-13T13:15:20Z", GoVersion:"go1.15.5", Compiler:"gc", Platform:"linux/amd64"}
</code></pre></div></div>

<p>Deployer et lancer rapidement un pod (methode imperative)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl run mynginx --image=nginx
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pod/mynginx created
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get all
NAME          READY   STATUS    RESTARTS   AGE
pod/mynginx   1/1     Running   0          3m26s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   37m
</code></pre></div></div>

<h1 id="les-principaux-objets-utilisés-par-kubernetes">Les principaux objets utilisés par Kubernetes</h1>

<h2 id="pods">Pods</h2>
<p>Est une abstration d’un serveur.  Un pod peut contenir plusieurs conteneurs dans un seul namespace et ils sont exposé via une seule adresse IP.</p>

<p>En production, un pod ne doit pas être demarré tout seul, il ne sera pas redeployer quand le noeud s’arrete. Un pod peut être créé à partir d’un deploiment, job ou cronjob.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">mynginx</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">mynginx</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl explain pods
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl explain pods.spec
</code></pre></div></div>

<p>Generalement, un pod contient un seul conteneur mais, dans certains cas on a besoin de lancer multiples conteneurs dans un pod:</p>

<ul>
  <li>init container : pour initialiser une configuration par exemple</li>
  <li>sidecar container : produire des fonctionnalités supplementaires au conteneur principal, par exemple gestion des logs, synchronisation, metriques, tracing</li>
  <li>ambassador container</li>
  <li>adapter container</li>
</ul>

<h3 id="initcontainers">InitContainers</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">initcontainer-example</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">initContainers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">sleepy</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">alpine</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sleep'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">20'</span><span class="pi">]</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
</code></pre></div></div>

<h3 id="comment-investiguer-un-probleme-dans-un-pod-">Comment investiguer un probleme dans un pod ?</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl describe pod podname 
</code></pre></div></div>
<p>Lit le status courant du pod dans la base de données etcd.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl logs podname
</code></pre></div></div>

<p>Lit le contenu stdout du pod, s’il y a plusieurs conteneurs il faut ajouter l’option -c avec le nom du conteneur</p>

<p>kubectl exec (executer une commande dans un conteneur, s’il y a plusieurs conteneurs il faut ajouter l’option -c)</p>

<p>kubectl get pods –all-namespaces -o wide</p>

<h3 id="securitycontext-dun-pod">securityContext d’un pod</h3>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span> 
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginxsecure</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">securityContext</span><span class="pi">:</span>
    <span class="na">runAsNonRoot</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span></code></pre></figure>

<h3 id="tester-laccessibilité-dun-pod">Tester l’accessibilité d’un pod</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl port-forward pod/podname port_externe:port_interne
</code></pre></div></div>
<h3 id="limitation-des-resources-utilisé-par-un-pod">Limitation des resources utilisé par un pod</h3>

<p>Par defaut un pod utilise autant de CPU et memoire pour faire son travail.
On peut controler l’utilisation des resources via pod.spec.containers.resources.</p>

<p>CPU : millicore (m), 1000m est l’equivalent d’un 1 CPU.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>requests:
limits:
</code></pre></div></div>

<h2 id="deployments">Deployments</h2>

<p>Une entité pour standardiser la gestion des pods. Un deployment crée un replicaset automatiquement.</p>

<p>Un deploiement permet de gerer le scalabilité de l’application, la strategie de mise à jour et l’historique.</p>

<p>Si un pod tombe en panne, le deploiement crée automatique un autre.</p>

<h2 id="services">Services</h2>

<h2 id="ingress">Ingress</h2>

<h2 id="persistent-volumes">Persistent Volumes</h2>

<h2 id="jobs">Jobs</h2>

<p>Pour executer une tache pendant un certain temps defini.</p>

<p>3 differentes type de jobs :</p>
<ul>
  <li>non-parallel jobs : completions=1 parallelism=1</li>
  <li>Parallel jobs : completions=n, parallelism=m</li>
  <li>Parallel jobs avec un queue : completions=1, parallelism=n</li>
</ul>

<h2 id="cronjobs">Cronjobs</h2>

<h2 id="namespace">Namespace</h2>
<p>Pour isoler les ressources dans le cluster. Par défaut, Kubernetes crée plusieurs namespaces : default, kube-node-lease, kube-public, kube-system.</p>

<p>Pour créer un namespace :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create ns ci-env
</code></pre></div></div>
<p>Pour lancer une requete d’un namespace, on utilise l’option “-n”</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl -n namespace get pods
</code></pre></div></div>
<p>Lister tous les namespaces</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get ns
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods --all-namespaces
</code></pre></div></div>

<h1 id="autorisation-et-permission">Autorisation et permission</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl auth can-i get pods
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl auth can-i get pods --as toto@test.com
</code></pre></div></div>

<h1 id="comment-on-developpe-pour-kubernetes-">Comment on developpe pour Kubernetes ?</h1>

<p>Build l’application -&gt; La conteneuriser -&gt; La deployer et executer sur K8S</p>

<h2 id="developpement-continue-avec-skaffold">developpement continue avec Skaffold</h2>
<p>https://skaffold.dev/</p>

<h1 id="operator">Operator</h1>

<p>un moyen d’etendre les ressources que l’API Serveur de Kubernetes peut gerer. On appelle ceci CRD (Custom Resource Definitions).</p>

:ET